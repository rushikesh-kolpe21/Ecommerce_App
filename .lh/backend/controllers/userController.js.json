{
    "sourceFile": "backend/controllers/userController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1769497725014,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1769589251436,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,14 +4,17 @@\n const jwt = require(\"jsonwebtoken\");\r\n \r\n // function to create JWT token\r\n const createToken = (id) => {\r\n-    return jwt.sign({ id }, process.env.JWT_SECRET, {\r\n-        expiresIn: '2d',\r\n-    });\r\n-}\r\n+  return jwt.sign(\r\n+    { id },                    // payload\r\n+    process.env.JWT_SECRET,    // secret key\r\n+    { expiresIn: '2d' }        // options\r\n+  );\r\n+};\r\n \r\n \r\n+\r\n // route for user registration\r\n const registerUser = async (req, res) => {\r\n     try {\r\n          const {userName, email, password} = req.body;\r\n@@ -67,9 +70,9 @@\n         if(!user){\r\n             return res.status(200).json({success: false, message: \"User not found. Please check your email\"});\r\n         }\r\n         // if user exit with matching password\r\n-        const isMatch = await bcrypt.compare(password, user.password);\r\n+        const isMatch = await bcrypt.compare(password, user.password); // new  old db\r\n \r\n         if(isMatch){\r\n             // generate token\r\n             const token = createToken(user._id);\r\n"
                }
            ],
            "date": 1769497725014,
            "name": "Commit-0",
            "content": "const userModel = require(\"../models/userModel\");\r\nconst validator = require(\"validator\");\r\nconst bcrypt = require(\"bcryptjs\");\r\nconst jwt = require(\"jsonwebtoken\");\r\n\r\n// function to create JWT token\r\nconst createToken = (id) => {\r\n    return jwt.sign({ id }, process.env.JWT_SECRET, {\r\n        expiresIn: '2d',\r\n    });\r\n}\r\n\r\n\r\n// route for user registration\r\nconst registerUser = async (req, res) => {\r\n    try {\r\n         const {userName, email, password} = req.body;\r\n\r\n         // checking if user already exists or not\r\n         const exists = await userModel.findOne({email});\r\n         if(exists){\r\n            return res.status(200).json({success: false, message: 'User already exists'});\r\n         }\r\n\r\n         // validating password length and email\r\n         if(!validator.isEmail(email)){\r\n            return res.status(200).json({success: false, message: 'Please enter a valid email'});\r\n         }\r\n         if(password.length < 6){\r\n            return res.status(200).json({success: false, message: 'Password must be at least 6 characters long'});\r\n         }\r\n\r\n        //  hashing password\r\n        const salt = await bcrypt.genSalt(10);\r\n        const hashedPassword = await bcrypt.hash(password, salt);\r\n\r\n         // creating new user\r\n         const newUser = new userModel({\r\n            name:userName,\r\n            email,\r\n            password : hashedPassword\r\n         });\r\n\r\n         // saving new user to database\r\n         await newUser.save();\r\n         \r\n        //  token generation can be added here\r\n            const token = createToken(newUser._id)\r\n            res.json({success:true, token})\r\n\r\n    } catch (error) {\r\n        console.log(error);\r\n        res.json({success:false, message:error.message});\r\n    }\r\n}\r\n\r\n\r\n// route for user login \r\nconst loginUser = async (req, res) => {\r\n    // res.json({ message: 'User login successful' });\r\n    try {\r\n\r\n        const {email, password} = req.body;\r\n\r\n        // if user not exit\r\n        const user = await userModel.findOne({email});\r\n        if(!user){\r\n            return res.status(200).json({success: false, message: \"User not found. Please check your email\"});\r\n        }\r\n        // if user exit with matching password\r\n        const isMatch = await bcrypt.compare(password, user.password);\r\n\r\n        if(isMatch){\r\n            // generate token\r\n            const token = createToken(user._id);\r\n            res.json({success:true, token});\r\n        } else {\r\n            // password doesn't match\r\n            return res.status(200).json({success: false, message: \"Invalid password\"});\r\n        }\r\n    } catch (error) {\r\n         console.log(error);\r\n        res.json({success:false, message:error.message})\r\n    }\r\n}\r\n\r\n// route for admin login\r\nconst loginAdmin = async (req, res) => {\r\n    try {\r\n         const {email, password} = req.body;\r\n\r\n         // checking admin credentials from .env file\r\n            if(email === process.env.ADMIN_EMAIL && password === process.env.ADMIN_PASSWORD){\r\n                const token = jwt.sign({ email, password }, process.env.JWT_SECRET, \r\n                    { expiresIn: '2d' });       \r\n                return res.json({success:true, token}); // send token to frontend\r\n            } else{\r\n                res.json({success:false, message:'Invalid admin credentials'});\r\n            }\r\n    } catch (error) {\r\n         console.log(error);                                     \r\n        res.json({success:false, message:error.message});           \r\n    }\r\n}\r\n\r\n\r\nmodule.exports = {\r\n    loginUser,\r\n    registerUser,\r\n    loginAdmin,  \r\n};"
        }
    ]
}